//////////////////////////////////////////////////////////////////////////////
/*
*
*  @par &copy; Copyright Hewlett-Packard Company, 2000-2018.
*  All rights reserved. Copying or other reproduction of this program except
*  for archival purposes is prohibited without written consent of
*  Hewlett-Packard Company.
* 
*  david.toussaint@hp.com
* 
**/ 
//////////////////////////////////////////////////////////////////////////////

/**< Extending boolean type with a default value */ 
enum BooleanPlusDefault: uint32_t
{ 
    BOOLEANPLUSDEFAULT_BOOLEAN_FALSE    = 0, /**< Requests a setting to be disabled */
    BOOLEANPLUSDEFAULT_BOOLEAN_TRUE     = 1, /**< Requests a setting to be enabled */
    BOOLEANPLUSDEFAULT_BOOLEAN_DEFAULT  = 2  /**< Used to let someone else to decide if a settings should be enabled/disabled (i.e. Let PDL choose the value) */
};

enum BorderlessMethod: uint32_t
{ 
    BORDERLESSMETHOD_AUTOFIT = 0, /**< The printer will expand the raster by the overspray values. Image ratio aspect can me modified. */
    BORDERLESSMETHOD_CROP    = 1  /**< The printer will start printing out of the paper by the overspray values. Original raster is not modified. */
};

enum ColorMode: uint32_t
{ 
    COLORMODE_UNDEFINED  = 0,
    COLORMODE_CMYK       = 1,
    COLORMODE_CMYKLITES  = 2,
    COLORMODE_CMYKLITESW = 3
};

/**< Color space being generated by the rip process or consumed by the print process. */ 
enum ColorSpace: uint32_t
{ 
    COLORSPACE_COLORSPACE_SRGB             = 0, /**< Standard RGB gamma 2.2 D65 white. The printer will apply the ICC associated with the media/printmode */
    COLORSPACE_COLORSPACE_DEVICECALIBRATED = 1  /**< Device calibrated color space. The raster color space has been modified on the RIP, the printer won't apply the ICC. This is the default value.*/
};

/**< Horizontal content alignment used when switching to a source with paper of a different width */ 
enum ContentAlignment: uint32_t
{ 
    CONTENTALIGNMENT_LEFT             = 0,  /**< Aligns content to the left */
    CONTENTALIGNMENT_CENTER           = 1,  /**< Aligns content to the center */
    CONTENTALIGNMENT_RIGHT            = 2,  /**< Aligns content to the right */
    CONTENTALIGNMENT_ALIGN_TO_PLATTEN = 3   /**< Aligns content to platten */
};

/**< Enable or disable cutter */
enum Cutter : uint32_t
{
    CUTTER_DISABLED = 0,    /**< Disable cutter for the whole job */
    CUTTER_ENABLED = 1,     /**< Enable cutter for the whole job. FP has precedence */
    CUTTER_JOB_DISABLED = 2 /**< Disable cutter for the internal pages in a job, but enable it for last page */
};

/**< Dry time modes. It specifies which of the drying time modes it applies for drying. For low ink density plots, like line drawing, selecting REDUCED improves troughput And for high ink density pages, selecting EXTENDED, would allow additional time to dry. Typically, NORMAL should work fine for most of the cases. The actual time on each of the options would depend on the media type. */
enum DryTimeMode : uint32_t
{
    DRYTIMEMODE_REDUCED = 0,    /**< Selects a reduced dry time for the specific media */
    DRYTIMEMODE_NORMAL = 1,     /**< Selects the normal dry time. */
    DRYTIMEMODE_EXTENDED = 2,   /**< Selects a extended dry time. */
    DRYTIMEMODE_NONE = 3        /**< Disables dry time. */
};

enum DualSide : uint32_t
{
    DUALSIDE_OFF = 0,
    DUALSIDE_A = 1,
    DUALSIDE_B = 2
};

enum DualSideOrder : uint32_t
{
    DUALSIDEORDER_OFF = 0,              /**< No Dual Side active. */
    DUALSIDEORDER_INTERLEAVED = 1,      /**< Print ABABAB…. */
    DUALSIDEORDER_NON_INTERLEAVED = 2,  /**< Print AAAAA…BBBBBB…. */
};

/**< Economode printmode selector. */
enum Economode : uint32_t
{
    ECONOMODE_OFF = 0,
    ECONOMODE_ON = 1
};

enum EfficiencyMode : uint32_t
{
    EFFICIENCYMODE_ON = 0,
    EFFICIENCYMODE_OFF = 1
};

enum ExtendedPM: uint32_t
{ 
    EXTENDEDPM_XPM0  = 0,
    EXTENDEDPM_XPM1  = 1,
    EXTENDEDPM_XPM2  = 2,
    EXTENDEDPM_XPM3  = 3,
    EXTENDEDPM_XPM4  = 4,
    EXTENDEDPM_XPM5  = 5,
    EXTENDEDPM_XPM6  = 6,
    EXTENDEDPM_XPM7  = 7,
    EXTENDEDPM_XPM8  = 8,
    EXTENDEDPM_XPM9  = 9,
    EXTENDEDPM_XPM10 = 10,
    EXTENDEDPM_XPM11 = 11,
    EXTENDEDPM_XPM12 = 12,
    EXTENDEDPM_XPM13 = 13,
    EXTENDEDPM_XPM14 = 14,
    EXTENDEDPM_XPM15 = 15,
    EXTENDEDPM_XPM16 = 16,
    EXTENDEDPM_XPM17 = 17,
    EXTENDEDPM_XPM18 = 18,
    EXTENDEDPM_XPM19 = 19
};

/**< Extra Passes printmode selector. */ 
enum ExtraPasses: uint32_t
{ 
    EXTRAPASSES_OFF = 0,
    EXTRAPASSES_ON  = 1
};

/**< Folding style that can be performed by the folder destination */ 
enum FoldingStyle: uint32_t
{ 
    FOLDINGSTYLE_CUSTOM   = 0,  /**< Folds the page using an explicit fan-fold, cross-fold, and margin values */
    FOLDINGSTYLE_STANDARD = 1   /**< Folds the page using a predefined folding style */
};

enum GlossEnhancer: uint32_t
{ 
    GLOSSENHANCER_OFF       = 0,
    GLOSSENHANCER_INKEDAREA = 1,
    GLOSSENHANCER_FULLPAGE  = 2
};

enum HighSpeed: uint32_t
{ 
    HIGHSPEED_ON  = 0,
    HIGHSPEED_OFF = 1
};

enum InkDensity: uint32_t
{ 
    INKDENSITY_UNDEFINED = 0,
    INKDENSITY_L4        = 16,
    INKDENSITY_L5        = 1,
    INKDENSITY_L6        = 2,
    INKDENSITY_L7        = 3,
    INKDENSITY_L8        = 4,
    INKDENSITY_L9        = 5,
    INKDENSITY_L10       = 6,
    INKDENSITY_L11       = 7,
    INKDENSITY_L12       = 8,
    INKDENSITY_L13       = 9,
    INKDENSITY_L14       = 17,
    INKDENSITY_L15       = 10,
    INKDENSITY_L16       = 18,
    INKDENSITY_L17       = 11,
    INKDENSITY_L18       = 12,
    INKDENSITY_L19       = 19,
    INKDENSITY_L20       = 13,
    INKDENSITY_L21       = 20,
    INKDENSITY_L22       = 21,
    INKDENSITY_L23       = 14,
    INKDENSITY_L24       = 22,
    INKDENSITY_L25       = 23,
    INKDENSITY_L26       = 15
};

/**< Collate scope */ 
enum JobCollate: uint32_t
{ 
    JOBCOLLATE_OFF  = 0,    /**< Collate disabled */
    JOBCOLLATE_ON   = 1     /**< Collate on a job basis */
};

enum MarginLayout: uint32_t
{ 
    MARGINLAYOUT_STANDARD     = 0,
    MARGINLAYOUT_OVERSIZE     = 1,
    MARGINLAYOUT_CLIP_INSIDE  = 2
};

/**< Margin Setting */ 
enum MarginSetting: uint32_t
{ 
    MARGINSETTING_NORMAL     = 0,
    MARGINSETTING_EXTENDED   = 1,
    MARGINSETTING_SMALLER    = 2,
    MARGINSETTING_NO_MARGINS = 3
};

/**< Maximum detail printmode selector. */ 
enum MaxDetail: uint32_t
{ 
    MAXDETAIL_OFF = 0,
    MAXDETAIL_ON  = 1
};

/**< Available output media destinations. Not all printers support all the possibilities. For example, some printers do not support stacker or folder. */ 
enum MediaDestination: uint32_t
{ 
    MEDIADESTINATION_AUTO              = 0, /**< Automatic media destination selection; let the printer choose the media destination bewteen bin, roll, stacker, folder... */
    MEDIADESTINATION_BIN               = 1, /**< Selects Bin as output destination. */
    MEDIADESTINATION_ROLL              = 2, /**< Selects Roll as destination. */
    MEDIADESTINATION_STACKER           = 3, /**< Selects Built-in Stacker as media output destination. */
    MEDIADESTINATION_FOLDER            = 4, /**< Selects Folder as media output destination. */
    MEDIADESTINATION_ACCESSORY_STACKER = 5, /**< Selects External Stacker as media output destination. */
    MEDIADESTINATION_GENERIC_ACCESSORY = 6, /**< Selects Generic Accessory as media output destination. */
    MEDIADESTINATION_SAME              = 7  /**< Use the same media destination as the original job. Only for reprint jobs. */
};

/**< Available media sources. Not all printers support all the possibilities. For example, some printers do not support cut sheet (manual feed), others only have one roll, etc. Even though ROLL means "any roll", some legacy printer models require that ROLL is sent instead of ROLL1 for single-roll SKUs. This is hidden from the client in this API, ROLL1 can be sent in this case. */ 
enum MediaSource: uint32_t
{ 
    MEDIASOURCE_MANUAL_FEED = 0,    /**< Selects manual feed / cut sheet. Equivalent to MANUALFEED in PJL. */
    MEDIASOURCE_ROLL1       = 1,    /**< Selects ROLL 1. Equivalent to ROLL1 in PJL. */
    MEDIASOURCE_ROLL2       = 2,    /**< Selects ROLL 2. Equivalent to ROLL2 in PJL. */
    MEDIASOURCE_ROLL3       = 3,    /**< Selects ROLL 3. Equivalent to ROLL3 in PJL. */
    MEDIASOURCE_ROLL4       = 4,    /**< Selects ROLL 4. Equivalent to ROLL4 in PJL. */
    MEDIASOURCE_ROLL5       = 5,    /**< Selects ROLL 5. Equivalent to ROLL5 in PJL. */
    MEDIASOURCE_ROLL6       = 6,    /**< Selects ROLL 6. Equivalent to ROLL6 in PJL. */
    MEDIASOURCE_ROLL        = 7,    /**< Automatic roll selection; let the printer choose which roll to use. Manual feed will not be chosen. Equivalent to ROLL in PJL. */
    MEDIASOURCE_AUTO        = 8,    /**< Automatic media source selection; let the printer choose the media source between cut sheet and any of the rolls. Equivalent to AUTO in PJL. */
    MEDIASOURCE_SAME        = 9,    /**< Use the same media source as the original job. Only for reprint jobs. */
    MEDIASOURCE_TRAY        = 10,   /**< Automatic tray media source selection; let the printer choose the media source between cut sheet and any of the trays. Equivalent to TRAY in PJL.*/
    MEDIASOURCE_TRAY1       = 11    /**< Selects TRAY 1. Equivalent to TRAY1 in PJL. */
};

enum PrintArea: uint32_t
{ 
    PRINTAREA_FULL_SIZE  = 0,   /**< Print the whole page size */
    PRINTAREA_INKED_AREA = 1    /**< Removes white areas. Depending on the printing engine it might remove top/bottom, or at the four sides This setting is applied after nesting */
};

/**< Printing quality. The list of values is potentially product-dependent, although all products to date have always supported at least FAST, NORMAL and BEST. */ 
enum PrintQuality: uint32_t
{ 
    PRINTQUALITY_FAST      = 0, /**< Fast print quality. */
    PRINTQUALITY_NORMAL    = 1, /**< Normal print quality. */
    PRINTQUALITY_BEST      = 2, /**< Best print quality. */
    PRINTQUALITY_MARVELOUS = 3  /**< Marvelous print quality. */
};

/**< Output page order considering the finishing */ 
enum PrintingOrder: uint32_t
{ 
    PRINTINGORDER_FIRST_PAGE_ON_TOP = 0,    /**< Page order depends on finishing so the front page gets on top */
    PRINTINGORDER_LAST_PAGE_ON_TOP  = 1,     /**< Page order depends on finishing so the back page gets on top */
    PRINTINGORDER_DIRECT = 2,    /**< First page will be the first to get printed*/
    PRINTINGORDER_REVERSE = 3    /**< First page will be last to get printed*/
};

/**< Color Rendering intent, as defined by the ICC. */ 
enum RenderIntent: uint32_t
{ 
    RENDERINTENT_PERCEPTUAL            = 0,
    RENDERINTENT_RELATIVE_COLORIMETRIC = 1,
    RENDERINTENT_SATURATION            = 2,
    RENDERINTENT_ABSOLUTE_COLORIMETRIC = 3

};

enum RenderMode: uint32_t
{ 
    RENDERMODE_COLOR         = 0,
    RENDERMODE_GRAYSCALE     = 1,
    RENDERMODE_TRUEGRAYSCALE = 2,
    RENDERMODE_BLACKANDWHITE = 3
};

/**< Available rendering resolutions NOTE: 72 dpi should only be used by previewing process */ 
enum RenderingResolution: uint32_t
{ 
    RENDERINGRESOLUTION_RES_72   = 72,
    RENDERINGRESOLUTION_RES_150  = 150,
    RENDERINGRESOLUTION_RES_200  = 200,
    RENDERINGRESOLUTION_RES_300  = 300,
    RENDERINGRESOLUTION_RES_400  = 400,
    RENDERINGRESOLUTION_RES_600  = 600,
    RENDERINGRESOLUTION_RES_1200 = 1200
};

/**< Resolution Enhancement Technology (RET). Aplied for CAD print modes. */
enum RetMode : uint32_t
{
    RETMODE_ON = 0,
    RETMODE_OFF = 1
};

/**< Algorithm used to automaticaly select media source */
enum RollSwitchPolicy : uint32_t
{
    ROLLSWITCHPOLICY_MAXIMIZE_PRODUCTIVITY = 0, /**< Selects the media source currently ready to print whenever possible */
    ROLLSWITCHPOLICY_LESS_REMAINING_PAPER = 1,  /**< Selects the media source with less paper remaining */
    ROLLSWITCHPOLICY_SAVE_PAPER = 2             /**< Selects the media source with the smaller media that fits */
};

/**< Unidirectional printmode selector. */
enum Unidirectional : uint32_t
{
    UNIDIRECTIONAL_OFF = 0,
    UNIDIRECTIONAL_ON = 1
};

enum WhiteMode: uint32_t
{ 
    WHITEMODE_UNDEFINED = 0, /**< White mode not defined */
    WHITEMODE_SPOT = 1,      /**< Spot white mode */
    WHITEMODE_UF = 2,        /**< White mode underflow */
    WHITEMODE_OF = 3,        /**< White mode overflow */
    WHITEMODE_SW3L = 4       /**< White mode SW3L */
};

/**< Vertical trimmer status. */
enum YCutter : uint32_t
{
    YCUTTER_ENABLED = 0,  /**< Vertical trimmer enabled */
    YCUTTER_DISABLED = 1  /**< Vertical trimmer disabled */
};

/**< White shrink algorithm status. */
enum WhiteShrink : uint32_t
{
    WHITESHRINK_DISABLED = 0, /**< Disable White shrink algorithm*/
    WHITESHRINK_ENABLED = 1   /**< Enable White shrink algorithm*/
};

/**< Overcoat setting. */
enum Overcoat : uint32_t
{
    OVERCOAT_OFF = 0, /**< Disable overcoat*/
    OVERCOAT_ON = 1   /**< Enable overcoat*/
};

/**< Flip edge setting. */
enum FlipEdge : uint32_t
{
    FLIPEDGE_UNDEFINED = 0,     /**< Flip edge not defined*/
    FLIPEDGE_LATERAL_EDGE = 1,  /**< Flip edge is the lateral side of the media*/
    FLIPEDGE_FRONT_EDGE = 2,    /**< Flip edge is the front side of the media*/
};

typedef uint32_t NumCopies;  /**< Number of copies, between 1 and 9999 */

typedef uint32_t PrivacyPin; 

struct MetricDistance
{
    double units;
    double unitsPerInch;

    MetricDistance(double d = 0) : units(d), unitsPerInch(0)
    {}
};

/**< Scan intents */
enum ScanIntent : uint32_t
{
    SCAN_INTENT_DOCUMENT         = 0,
    SCAN_INTENT_TEXT_AND_GRAPHIC = 1,
    SCAN_INTENT_PHOTO            = 2,
    SCAN_INTENT_PREVIEW          = 3,
    SCAN_INTENT_BUSSINESS_CARD   = 4
};

enum ScanDocumentFormat : uint32_t
{
    SCAN_FORMAT_APPLICATION_UNKNOWN                               = 0,  // Unknown MIME type
    SCAN_FORMAT_APPLICATION_OCTETSTREAM                           = 1,  // MIME type: application/octet-stream
    SCAN_FORMAT_APPLICATION_PDF                                   = 2,  // MIME type: application/pdf
    SCAN_FORMAT_APPLICATION_POSTSCRIPT                            = 3,  // MIME type: application/postscript
    SCAN_FORMAT_APPLICATION_VND_PWG_XHTML_PRINT_XML               = 4,  // MIME type: application/vnd.pwg-xhtml-print+xml
    SCAN_FORMAT_APPLICATION_VND_HP_PCL                            = 5,  // MIME type: application/vnd.hp-PCL
    SCAN_FORMAT_APPLICATION_VND_HP_CLOUD_EPRINT_SCAN_GSR_1_0_ZLIB = 6,  // MIME type: application/vnd.hp.cloud.eprint.scan.gsr.1.0+zlib
    SCAN_FORMAT_IMAGE_G3FAX                                       = 7,  // MIME type: image/g3fax
    SCAN_FORMAT_IMAGE_JPEG                                        = 8,  // MIME type: image/jpeg
    SCAN_FORMAT_IMAGE_PNG                                         = 9,  // MIME type: image/jpeg
    SCAN_FORMAT_IMAGE_TIFF                                        = 10, // MIME type: image/tiff
    SCAN_FORMAT_IMAGE_TIFF_FX                                     = 11, // MIME type: image/tiff-fx
    SCAN_FORMAT_TEXT_HTML                                         = 12, // MIME type: text/html
    SCAN_FORMAT_TEXT_PLAIN                                        = 13, // MIME type: text/plain
    SCAN_FORMAT_TEXT_PLAIN_CHARSET_ISO_8859_1                     = 14, // MIME type: text/plain; charset=ISO-8859-1
    SCAN_FORMAT_TEXT_PLAIN_CHARSET_US_ASCII                       = 15, // MIME type: text/plain; charset=US-ASCII
    SCAN_FORMAT_TEXT_PLAIN_CHARSET_UTF_8                          = 16, // MIME type: text/plain; charset=utf-8
};

enum ScanContentType : uint32_t
{
    SCAN_CONTENT_AUTO           = 0, // The scanner will choose
    SCAN_CONTENT_TEXT           = 1,
    SCAN_CONTENT_PHOTO          = 2,
    SCAN_CONTENT_TEXT_AND_PHOTO = 3,
    SCAN_CONTENT_LINE_ART       = 4,
    SCAN_CONTENT_MAGAZINE       = 5,
    SCAN_CONTENT_HALFTONE       = 6
};

enum ScanInputSource : uint32_t
{
    SCAN_INPUT_PLATEN = 0, // Glass flat bed
    SCAN_INPUT_FEEDER = 1, // Automatic Document Feeder (ADF)
};

enum ScanFeedDirection : uint32_t
{
    SCAN_FEED_DIRECTION_LONG_EDGE  = 0, // Media is placed on the scanbed such that the longest edge is scanned first. Scanner may change the orientation after the scan is completed
    SCAN_FEED_DIRECTION_SHORT_EDGE = 1  // Media is placed on the scanbed such that the shortest edge is scanned first.
};

enum ScanColorMode : uint32_t
{
    SCAN_COLOR_MODE_BLACK_AND_WHITE_1 = 0, // Black and white - 1 bit per pixel. Only valid for SCAN_FORMAT_APPLICATION_OCTETSTREAM documents
    SCAN_COLOR_MODE_GRAYSCALE_4       = 1, // Grayscale - 4 bits per pixel
    SCAN_COLOR_MODE_GRAYSCALE_8       = 2, // Grayscale - 8 bits per pixel
    SCAN_COLOR_MODE_GRAYSCALE_16      = 3, // Grayscale - 16 bits per pixel
    SCAN_COLOR_MODE_RGB_24            = 4, // RGB - 24 bits per pixel
    SCAN_COLOR_MODE_RGB_48            = 5, // RGB - 48 bits per pixel
    SCAN_COLOR_MODE_RGBA_32           = 6, // RGBA - 32 bits per pixel
    SCAN_COLOR_MODE_RGBA_64           = 7, // RGBA - 64 bits per pixel
    SCAN_COLOR_MODE_CMYK_32           = 8, // CMYK - 32 bits per pixel
    SCAN_COLOR_MODE_AUTO              = 9  // The scanner detects the color automatically. the ScanColorAutodetection setting must be set 
};

enum ScanColorAutodetectionMode : uint32_t
{
    SCAN_COLOR_AUTODETECTION_DETECT_ONLY                          = 0, // Only color detection. Returns RGB data as SCAN_COLOR_MODE_RGB_24
    SCAN_COLOR_AUTODETECTION_TREAT_NON_COLOR_AS_BLACK_AND_WHITE_1 = 1, // If no color detected returns black and white data as SCAN_COLOR_MODE_BLACK_AND_WHITE_1
    SCAN_COLOR_AUTODETECTION_TREAT_NON_COLOR_AS_GRAYSCALE_8       = 2  // If no color detected returns grayscale 8-bits data as SCAN_COLOR_MODE_GRAYSCALE_8
};

enum ScanColorSpace : uint32_t
{
    SCAN_COLOR_SPACE_RGB     = 0,         
    SCAN_COLOR_SPACE_SRGB    = 1,        
    SCAN_COLOR_SPACE_SCRGB   = 2,       
    SCAN_COLOR_SPACE_CMY     = 3,         
    SCAN_COLOR_SPACE_CMYK    = 4,        
    SCAN_COLOR_SPACE_YCC     = 5         
};

enum ScanMediaType : uint32_t
{
    SCAN_MEDIA_TYPE_WHITE        = 0, 
    SCAN_MEDIA_TYPE_PHOTO        = 1,
    SCAN_MEDIA_TYPE_BLUEPRINT    = 2,
    SCAN_MEDIA_TYPE_OLD_RECICLED = 3,
    SCAN_MEDIA_TYPE_TRANSLUCENT  = 4
};

enum ScanCcdChannel : uint32_t
{
    SCAN_CCD_NTSC           = 0, // NTSC is a weighted combination of the three color channels optimized for photos.
    SCAN_CCD_GRAY           = 1, // Requires a dedicated Gray CCD array in the hardware (optimized for documents)
    SCAN_CCD_GRAY_EMULATED  = 2, // Emulated Gray CCD mode where each CCD line are given even weight (1/3 R, 1/3 G, 1/3 B) (optimized for documents). This only applies to SCAN_COLOR_MODE_BLACK_AND_WHITE_1, SCAN_COLOR_MODE_GRAYSCALE_8 and SCAN_COLOR_MODE_GRAYSCALE_16 color modes.
    SCAN_CCD_RED            = 3,
    SCAN_CCD_GREEN          = 4,
    SCAN_CCD_BLUE           = 5
};

enum ScanBinaryRendering : uint32_t
{
    SCAN_BINARY_RENDERING_HALFTONE       = 0,
    SCAN_BINARY_RENDERING_THRESHOLD      = 1,
    SCAN_BINARY_RENDERING_ERROR_DIFUSION = 2
};
